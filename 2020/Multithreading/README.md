# Многопоточность

ДЗ 1
Цель задания
В этом домашнем задании вы поработаете на практике с потоками в приложении,
выполните длительную работу в фоновом потоке, а также распараллелите её на
несколько потоков.
Вы научитесь работать с инструментами, которые предоставляет Android для работы с
многопоточностью: Looper, MessageQueue, Handler.
Что нужно сделать
1. Подтяните проект в папке Multithreading из репозитория learning_materials /
   android_basic .
   — В проекте настроено получение из сети фильма по его идентификатору.
   — Фильм представлен классом Movie в проекте.
2. Получите API_KEY по ссылке: http://www.omdbapi.com/apikey.aspx , выберите
   Account Type FREE.
3. Вставьте полученный API_KEY в константу MOVIE_API_KEY файла Network.kt.
4. Реализуйте ThreadingFragment, чтобы в нём находился RecyclerView, который
   отображает список фильмов. Adapter должен работать с объектами класса
   Movie.
5. Получите информацию по фильмам последовательно в главном потоке:
   «Матрица», «Бойцовский клуб», «Форрест Гамп», «Крёстный отец», «Властелин
   колец: Две крепости». Или по любым другим фильмам по вашему усмотрению.
   Для этого найдите идентификатор IMDB фильмов: перейдите на сайт
   https://www.imdb.com , найдите фильм в разделе Top rated movies. Перейдите в
   детальную информацию по фильму. В адресной строке будет URL вида
   https://www.imdb.com/title/ tt0167261 , выделенная часть — и есть идентификатор
   фильма.
   Для получения информации о фильме из сети используйте метод
   Network.getMovieById.
6. Посмотрите, какая ошибка была выброшена при получении данных из сети в
   главном потоке, сохраните скриншот ошибки в корне проекта.
7. Получите информацию по фильмам в фоновых потоках параллельно,
   используя класс Thread. Каждый фильм запрашивается одним потоком.
   Отобразите полученные фильмы во фрагменте. Для оповещения о завершении
   получения фильмов используйте механизм колбеков.
8. Используйте Handler, связанный с MessageQueue главного потока, чтобы
   установить полученный список фильмов в адаптер.
9. Отобразите тост «Список обновлён» через одну секунду после получения
   списка фильмов. Для этого используйте Handler.
10. *Используйте Thread pool вместо потоков, чтобы получить фильмы из сети.
    Количество потоков должно равняться количеству ядер у процессора вашего
    устройства. Для этого изучите статью из дополнительных материалов.
11. *Добавьте SwipeRefreshLayout на экран со списками фильмов. Когда
    пользователь тянет список вниз, фильмы должны обновляться из сети.
    Рекомендации
    Используйте репозиторий learning_materials/android_basic .
    Скачайте изменения в репозитории на локальную машину.
    Выполните домашнее задание в папке Multithreading.
    Отправьте коммиты в удалённый репозиторий.
    Критерии оценки
    ● Код оформлен в соответствии с правилами
    https://kotlinlang.org/docs/reference/coding-conventions.html .
    ● Соблюдён принцип инкапсуляции с помощью модификаторов доступа.
    ● Классы являются не финальными (open, abstract) только при необходимости.
    ● Текстовые строки не захардкожены и используются из ресурсов.
    ● Получение информации по фильмам происходит в фоновых потоках.
    ● В проекте отсутствуют race condition, deadlock, livelock.
    ● Выполнены все пункты задания.
    Дополнительные материалы
    https://android.jlelse.eu/executor-framework-understanding-the-basics-43d575e72310 —
    работа с Executor.
    https://medium.com/@frank.tan/using-a-thread-pool-in-android-e3c88f59d07f — Using a
    Thread Pool in Android.
    https://developer.android.com/training/swipe/add-swipe-interface — работа с
    Swiperefreshlayout.


ДЗ 2
Цель задания
В этом домашнем задании вы воспроизведёте проблемы многопоточности, которые
обсуждались в модуле, и устраните их.
Описание задания
1. Воспроизведите и исправьте Race condition.
2. Добавьте 2 EditText, 2 Button, TextView во фрагменте RaceConditionFragment.
3. Первый EditText должен указывать количество потоков N.
4. Второй EditText должен указывать число, на которое каждый поток
   инкрементирует переменную M .
5. Сделайте, чтобы по нажатию на первую Button N потоков параллельно
   инкрементировали переменную по M раз каждый. По окончании инкремента в
   TextView должен устанавливаться текст с ожидаемым значением и реальным, а
   также временем инкремента переменной. Синхронизации критической секции в
   данном случае быть не должно.
6. Выполните предыдущий пункт по нажатию на вторую Button, только с
   синхронизацией критической секции.
7. Сравните время инкремента в обоих подходах. Найдите числа N/M, при
   которых race condition почти не воспроизводится.
8. Напишите код во фрагменте DeadlockFragment, который будет воспроизводить
   ситуацию Deadlock на примере двух потоков и инкрементирования переменной.
   Исправьте код, чтобы ситуации deadlock не возникало.
9. *Напишите код во фрагменте LivelockFragment, который будет воспроизводить
   и исправлять livelock.
   Рекомендации
   В качестве основы используйте проект из предыдущего домашнего задания.
   Для EditText в RaceConditionFragment используйте корректный inputType для ввода
   цифр.
   Не забудьте сбрасывать значение переменной счётчика в RaceConditionFragment при
   нажатии на кнопку.
   Критерии оценки
1. Код оформлен в соответствии с правилами
   https://kotlinlang.org/docs/reference/coding-conventions.html .
2. Соблюдён принцип инкапсуляции с помощью модификаторов доступа.
3. Классы являются не финальными (open, abstract) только при необходимости.
4. Текстовые строки не захардкожены и используются из ресурсов.
5. В каждом фрагменте есть пример реализации с race condition/deadlock/livelock и
   исправленный вариант, в котором проблема отсутствует